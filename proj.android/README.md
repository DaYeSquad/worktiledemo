# Android Demo (1)
# 用于演示该技术架构最简单的原理

# 环境
使用 Android Studio Beta 7，具体的参数可以见 app/build.gradle

# C++ 部分
C++ 的共享部分代码位于 core 中，第三方库位于 vendor 中，在这个示例中，我们引用了 json11 用于 json 的解析，在该示例中，我们创建了一个最常见的"用户"对象(User)，我们将用户对象设计为 new + init 的初始化方式并且提供 JSON 的初始化代码以及模拟了一个含有逻辑的方法 User::StatusDescription (非 Getter/Setter)。
在这个示例中，一共有两处是省下重复代码的地方:

1. User::InitWithJsonOrDie : 在以往 JSON 的初始化每个平台都需要实现一次，在服务端提供良好的文档的情况下加上每个客户端都有不错的 mapping 框架也许没什么特别大的困难，但是，如果在公司早期服务端并没有特别好的文档习惯的时候这种模式更能省下大量的时间，并且，在第三节中，我们将会提供代码自动构建工具完成重复性方法的构建。

2. User::StatusDescription : 这里模拟的是一个有逻辑处理的方法，并且逻辑处理中可能含有加密、解密、复杂的类型计算等，提取到 C++ 层后一方面在 Android 端具有更好的保密性，一方面可以省下多倍的对此处单元测试的代码。

注释:

1. User 也可以在 constructor 中完成所有的参数的初始化，不过在初始化比较复杂的地方推荐使用 init,为了形成一种开发人员可以固定的"模式"，我们在所有地方都采用了 new + init 的写法，我们认为一种固定的写法不仅利于初级开发者寻找方式，也更方便了代码构建工具生成代码。

2. 在第三方库的选用上，对于 App 开发，我们认为 JSON、XML 花式解析上的性能差异几乎可以不被用户感知，所以我们在库的选用上主要以轻量级为准则，尽量选用小型库，这一方面也非常便于我们编译 prebuilt。

# Java 以及 JNI 部分
该部分代码位于 android 以及 jni 文件夹下，该部分代码与传统的 JNI 代码并没有什么区别，不过在 Android 中使用 C++ 构建的类我们面对了一个产生了不少问题的地方:需要释放内存 (CoreObject.dispose())，在实践中，我们延续了"谁拥有、谁释放的原则"，建议让每个 Activity/Fragment 自行"拥有" CoreObject，并且在 onDestory 方法中释放自己拥有的 CoreObject，严格禁止 Activity 之间传递 CoreObject (我们将在第二节介绍我们的编程模式，简单的来说，我们在 HTTP 请求成功后会将缓存存入 SQLite 中，这样，在第二个界面中，我们就可以通过缓存或者发起一个网络请求获得对象，这样，我们传递的参数将只有对象的 ID，这样通常不会造成内存问题，并且可以通过自行制作简单的代码 new/dispose 检查工具检查下代码 new/dispose 的情况是否正确)。
